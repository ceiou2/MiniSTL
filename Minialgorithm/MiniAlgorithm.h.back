//MiniAlgorithm.h
#pragma once
#ifndef MINI_ALGORITHM_H
#define MINI_ALGORITHM_H

#include<cstddef>

/*
**************************************************************
========================以下为函数声明模块=======================
**************************************************************
*/
///////////////////不改变序列的操作///////////
//=============批量操作================
// for_each
//对范围 [first, last) 中每个迭代器的解引用结果应用给定的函数对象
// f。忽略 f返回的结果。
template<class InputIt, class UnaryFunc>
UnaryFunc for_each(InputIt first, InputIt last, UnaryFunc f);
///////////////////修改序列的操作////////////


///////////////////排序和相关操作////////////
//=============最大最小操作=============
// min_element
//寻找范围 [first, last) 中的最小元素。
template<class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template<class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);

// min
//返回给定值中的较小者。
template<typename T>
const T& min(const T& a, const T& b);

template<typename T, typename Compare>
const T& min(const T& a, const T& b, Compare comp);

template<typename T>
T min(std::initializer_list<T> ilist);

template<typename T, typename Compare>
T min(std::initializer_list<T> ilist, Compare comp);

// max_element
//寻找范围 [first, last) 中的最大元素。
template<class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template<class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);

// max
//返回给定值中的较大者。
template<class T>
const T& max(const T& a, const T& b);

template<class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template<class T>
T max(std::initializer_list<T> ilist);

template<class T, class Compare>
T max(std::initializer_list<T> ilist, Compare comp);

/*
**************************************************************
========================以下为函数定义模块=======================
**************************************************************
*/
///////////////////不改变序列的操作///////////
//=============批量操作================
// for_each
//对范围 [first, last) 中每个迭代器的解引用结果应用给定的函数对象
// f。忽略 f返回的结果。
template<class InputIt, class UnaryFunc>
UnaryFunc for_each(InputIt first, InputIt last, UnaryFunc f){
    for (; first != last; ++first)
        f(*first);

    return f;
}

///////////////////修改序列的操作////////////


///////////////////排序和相关操作////////////
//=============最大最小操作=============
// min_element
//寻找范围 [first, last) 中的最小元素。

template<class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last)
{
    ForwardIt res = first;
    while (first != last) {
        if (*first < *res)
            res = first;
        ++first;
    }
    return res;
}

template<class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp)
{
    ForwardIt res = first;
    while (first != last) {
        if (comp(*first, *res))
            res = first;
        ++first;
    }
    return res;
}

// min
//返回给定值中的较小者。
template<typename T>
const T& min(const T& a, const T& b)
{
    return (b < a) ? b : a;
}

template<typename T, typename Compare>
const T& min(const T& a, const T& b, Compare comp)
{
    return (comp(b,a)) ? b : a;
}

template<typename T>
T min(std::initializer_list<T> ilist){
    return *min_element(ilist.begin(), ilist.end());
}

template<typename T, class Compare>
T min(std::initializer_list<T> ilist, Compare comp){
    return *min_element(ilist.begin(), ilist.end(), comp);
}


// max_element
//寻找范围 [first, last) 中的最大元素。
template<class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last){
    ForwardIt res = first;
    while (first != last) {
        if (*first > *res)
            res = first;
        ++first;
    }
    return res;
}

template<class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp){
    ForwardIt res = first;
    while (first != last) {
        if (comp(*res, *first))
            res = first;
        ++first;
    }
    return res;
}

// max
//返回给定值中的较大者。
template<class T>
const T& max(const T& a, const T& b){
    return (a < b) ? b : a;
}

template<class T, class Compare>
const T& max(const T& a, const T& b, Compare comp){
    return (comp(a, b)) ? b : a;
}

template<class T>
T max(std::initializer_list<T> ilist){
    return *max_element(ilist.begin(), ilist.end());
}

template<class T, class Compare>
T max(std::initializer_list<T> ilist, Compare comp){
    return *max_element(ilist.begin(), ilist.end(), comp);
}

#endif
